use crate::{
    components::detect_mobile_device,
    models::chatlog::{Chatlog, Message, parse_think_block},
};
use sycamore::prelude::*;
use web_sys::KeyboardEvent;

/// Renders a chat message component with different styling for user and AI messages.
///
/// The component displays messages with different positioning and colors depending on whether
/// the message was generated by an AI or a user. User messages appear on the right side with
/// a blue background, while AI messages appear on the left side with a gray background.
#[component(inline_props)]
pub fn ChatMessageComponent(msg: Message) -> View {
    // get the chatlog context to track changes
    let chatlog = use_context::<Signal<Chatlog>>();
    let tracked_message = chatlog.get_clone_untracked().track_message(msg.id);
    let msg_content = create_signal(String::new());
    let msg_image = create_signal(None::<String>);
    let selected_index = create_signal(msg.selected_message);
    let stack_len = create_signal(msg.message_stack.len());

    // signal for tracking if think block is expanded, unexpanded by default
    let show_think_block = create_signal(false);

    create_effect(move || {
        if let Some(current_msg) = tracked_message.get_clone() {
            if let Some(selected) = current_msg.get_selected_message() {
                msg_content.set(selected.message.clone());
                msg_image.set(selected.image_base64.clone());
                selected_index.set(current_msg.selected_message);
            }
            stack_len.set(current_msg.message_stack.len());
        }
    });

    // grab the active message to render; should *always* be a valid reference, but
    // we use a default message here for safety.
    debug_assert!(msg.get_selected_message().is_some());
    
    let is_editing = create_signal(false);
    let show_actions = create_signal(false);
    let toggle_actions = move |_| {
        show_actions.set(!show_actions.get());
    };

    let handle_edit_done = move || {
        is_editing.set(false);

        let new_msg = msg_content.get_clone_untracked();
        if !new_msg.trim().is_empty() {
            let mut active_chatlog = use_context::<Signal<Chatlog>>().get_clone_untracked();
            active_chatlog.update_msg(msg.id, new_msg, msg_image.get_clone());
            show_actions.set(false);
        }
    };

    let handle_remove_image = move || {
        msg_image.set(None);
        let mut active_chatlog = use_context::<Signal<Chatlog>>().get_clone_untracked();
        active_chatlog.update_msg(msg.id, msg_content.get_clone(), None);
    };

    let handle_purge_msgs = move || {
        let confirmed = window().confirm_with_message(
            "Are you sure you want to delete this message AND all older messages also?",
        );
        if let Ok(is_ok) = confirmed {
            if is_ok {
                let mut active_chatlog = use_context::<Signal<Chatlog>>().get_clone_untracked();
                active_chatlog.purge_messages(msg.id);
            }
        }
    };

    let handle_delete_msg = move || {
        let confirmed =
            window().confirm_with_message("Are you sure you want to delete this message?");
        if let Ok(is_ok) = confirmed {
            if is_ok {
                let mut active_chatlog = use_context::<Signal<Chatlog>>().get_clone_untracked();
                active_chatlog.remove_message(msg.id);
            }
        }
    };

    let handle_regeneration = move || {
        let active_chatlog = use_context::<Signal<Chatlog>>();
        active_chatlog.update(|log| {
            log.is_regenerating_msg.set(true);
        });

        let log = active_chatlog.get_clone();
        log.trigger_response_generation();
        show_actions.set(false);
    };

    view! {
    div (class = if !msg.ai_generated {
        "message-container-user"
    } else {
        "message-container-ai"
    }) {
        div (class = if !msg.ai_generated {
            "message-bubble-user"
        } else {
            "message-bubble-ai"
        }) {
            // Show text or input based on editing state
            div (class="message-content") {
                (if !is_editing.get() {
                    // Check for think block by setting up a msg clone with the edited content
                    // from the signal
                    let maybe_msg_has_thoughts = parse_think_block(msg_content.get_clone());

                    if let Some((main_content, think_content)) = maybe_msg_has_thoughts.clone() {
                        let markdown_content = ammonia::clean(&markdown::to_html(&main_content));
                        view! {
                            div{
                                div(class="think-block-header", on:click=move |_| {
                                    show_think_block.set(!show_think_block.get());
                                }) {
                                    "Thought Process "
                                    span(class="think-toggle") {
                                        (if show_think_block.get() { "▼" } else { "▶" })
                                    }
                                }
                                div(class=if show_think_block.get() { "think-block-content" } else { "hidden" }) {
                                    (think_content)
                                }

                                div (class="mt-4", dangerously_set_inner_html=markdown_content)
                            }
                        }
                    } else {
                        let markdown_content = ammonia::clean(&markdown::to_html(msg_content.get_clone().as_str()));

                        view! {
                            div(dangerously_set_inner_html=markdown_content)
                        }
                    }
                } else {
                    view! {
                        textarea(
                            rows = "5",
                            class = "message-content-editable block",
                            bind:value = msg_content,
                            on:blur = move |_| {
                                handle_edit_done();
                            },
                            on:keydown = move |e:KeyboardEvent| {
                                if !detect_mobile_device() {
                                    if e.key() == "Enter" && !e.shift_key() {
                                        e.prevent_default();
                                        handle_edit_done();
                                    }
                                }
                            },
                        )
                    }
                })

                (if let Some(data_url_str) = msg_image.get_clone() {
                    if !is_editing.get() {
                        view! {
                            div {
                                img(src=data_url_str, alt="Image for Message", class="message-image")
                            }
                        }
                    } else {
                        view! {
                            div(class="flex flex-col items-start") {
                                div(class="relative") {
                                    img(src=data_url_str, alt="Image for Message", class="message-image")
                                    button(
                                        on:click=move |_| {
                                            handle_remove_image();
                                        },
                                        class="input-image-remove-button"
                                    ) {
                                        "X"
                                    }
                                }
                            }
                         }
                    }
                } else {
                    view! { }
                })
            }

            div(class="message-actions") {
                div(
                    class = "action-badge",
                    on:click = toggle_actions
                ) { "~"}
                div(
                    class = if show_actions.get() {
                        "actions-row"
                    } else {
                        "hidden"
                    }
                    ) {
                        button(
                            class="action-button",
                            on:click=move |_| {
                                handle_purge_msgs();
                            }
                        ) { "Purge" }
                        button(
                            class="action-button",
                            on:click=move |_| {
                                handle_delete_msg();
                            }
                        ) { "Delete" }

                        span(class="action-separator") { "|" }

                        button(
                            class="action-button",
                            on:click=move |_| {
                                is_editing.set(!is_editing.get())
                            }
                        ) { "Edit" }
                        button(
                            class="action-button",
                            on:click=move |_| {
                                handle_regeneration();
                            }
                        ) { "Regenerate" }

                        (if stack_len.get() > 1 {
                            view! {
                                span(class="action-separator") { "|" }
                                button(
                                    class="action-button",                                    
                                    on:click=move |_| {
                                        let active_chatlog = use_context::<Signal<Chatlog>>();
                                        active_chatlog.get_clone().update_selected_index(msg.id, -1);
                                        active_chatlog.update(|log| {
                                            if let Some(msg) = log.get_message(msg.id) {
                                                let selected_msg = msg.get_selected_message().unwrap();
                                                msg_content.set(selected_msg.message);
                                                msg_image.set(selected_msg.image_base64);
                                            }
                                        });
                                        selected_index.set(selected_index.get().saturating_sub(1));
                                    },
                                ) { "Prev" }

                                p { (format!("{}/{}", selected_index.clone().get() + 1, stack_len.get())) }

                                button(
                                    class="action-button",
                                    on:click=move |_| {
                                        let active_chatlog = use_context::<Signal<Chatlog>>();
                                        active_chatlog.get_clone().update_selected_index(msg.id, 1);
                                        active_chatlog.update(|log| {
                                            if let Some(msg) = log.get_message(msg.id) {
                                                let selected_msg = msg.get_selected_message().unwrap();
                                                msg_content.set(selected_msg.message);
                                                msg_image.set(selected_msg.image_base64);                                            }
                                        });
                                        selected_index.set((selected_index.get() + 1).min(stack_len.get() - 1));
                                    },
                                ) { "Next" }
                            }
                        } else {
                            view! {}
                        })

                    }
                }
            }
        }
    }
}
